<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chess Teacher (Drag-and-Drop, Free)</title>
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs/dist/chessboard-1.0.0.min.css">
  <style>
    body { font-family: sans-serif; background: #f5f5f7;}
    #container { max-width: 560px; margin: 40px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #aaa; padding: 24px;}
    #board { margin: 0 auto 16px auto; }
    #controls { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;}
    #moves { background: #fafafa; border: 1px solid #eee; border-radius: 6px; padding: 8px; margin-bottom: 16px; font-size: 0.95em; min-height: 32px;}
    .move { margin-right: 8px; }
    select, button { padding: 7px; border-radius: 4px; border: 1px solid #bbb; font-size: 1em;}
    button { background: #3369e7; color: #fff; border: none;}
    button:hover { background: #2856b6;}
    .info { margin: 8px 0; color: #222;}
    #helpInfo { margin-top: 8px; color: #1a5e23;}
  </style>
</head>
<body>
  <div id="container">
    <h2>Chess Teacher (Drag Pieces!)</h2>
    <div id="board"></div>
    <div id="controls">
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
      <button id="helpBtn">Help (Best Move)</button>
      <button id="newBtn">New Match</button>
      <button id="replayBtn">Replay Match</button>
    </div>
    <div id="moves"></div>
    <div id="helpInfo"></div>
    <div id="info" class="info"></div>
  </div>
<script src="https://unpkg.com/@chrisoakman/chessboardjs/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chess.js@1.0.0/chess.min.js"></script>
<script>
  // Uses chess.js, chessboard.js (both MIT, no account), Lichess APIs for bot/help
  const movesDiv = document.getElementById('moves');
  const newBtn = document.getElementById('newBtn');
  const replayBtn = document.getElementById('replayBtn');
  const helpBtn = document.getElementById('helpBtn');
  const infoDiv = document.getElementById('info');
  const difficultySel = document.getElementById('difficulty');
  const helpInfo = document.getElementById('helpInfo');
  let chess = new Chess();
  let gameMoves = [];
  let replaying = false;
  let board;
  let botThinking = false;

  function updateUI() {
    board.position(chess.fen());
    movesDiv.innerHTML = chess.history({verbose:true}).map((m,i) =>
      `<span class="move">${i%2==0?(Math.floor(i/2)+1)+'.':''}${m.san}</span>`).join('');
    infoDiv.textContent = chess.game_over() ? (
      chess.in_draw() ? 'Draw!' : (chess.turn() === 'w' ? 'Black wins!' : 'White wins!')
    ) : 'Your turn: ' + (chess.turn() === 'w' ? 'White' : 'Black');
    helpInfo.textContent = '';
  }

  async function botMove() {
    if (chess.game_over()) return;
    botThinking = true;
    infoDiv.textContent = 'Bot thinking...';
    let move;
    if (difficultySel.value === 'easy') {
      const legal = chess.moves();
      move = legal[Math.floor(Math.random()*legal.length)];
    } else if (difficultySel.value === 'medium') {
      move = await getMostPopularMove(chess.fen());
    } else {
      move = await getBestMove(chess.fen(), chess.turn());
    }
    if (move && chess.move(move)) {
      gameMoves.push(move);
      updateUI();
    } else {
      infoDiv.textContent = "Bot cannot move.";
    }
    botThinking = false;
  }

  async function getMostPopularMove(fen) {
    try {
      const res = await fetch(`https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}`);
      const data = await res.json();
      if (data.moves && data.moves.length) return data.moves[0].san;
    } catch(e) {}
    const legal = chess.moves();
    return legal[Math.floor(Math.random()*legal.length)];
  }

  async function getBestMove(fen, turn) {
    try {
      const res = await fetch(`https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}`);
      const data = await res.json();
      if (data.pvs && data.pvs[0] && data.pvs[0].moves) {
        const sanMove = fenToSan(fen, data.pvs[0].moves.split(' ')[0]);
        return sanMove;
      }
    } catch(e) {}
    return await getMostPopularMove(fen);
  }

  function fenToSan(fen, uci) {
    const tmp = new Chess(fen);
    return tmp.move({from: uci.slice(0,2), to: uci.slice(2,4), promotion: uci.slice(4,5)}).san;
  }

  function onDrop(source, target) {
    if (chess.game_over() || botThinking) return 'snapback';
    const move = chess.move({from: source, to: target, promotion: 'q'});
    if (move === null) return 'snapback';
    gameMoves.push(move.san);
    updateUI();
    setTimeout(botMove, 400);
  }

  function onSnapEnd() {
    board.position(chess.fen());
  }

  newBtn.onclick = () => {
    chess = new Chess();
    gameMoves = [];
    replaying = false;
    updateUI();
    infoDiv.textContent = "New match started.";
  };

  replayBtn.onclick = async () => {
    if (!gameMoves.length) return;
    chess = new Chess();
    replaying = true;
    board.position(chess.fen());
    movesDiv.innerHTML = '';
    infoDiv.textContent = "Replaying match...";
    for (const m of gameMoves) {
      await new Promise(r=>setTimeout(r, 650));
      chess.move(m);
      board.position(chess.fen());
      movesDiv.innerHTML = chess.history({verbose:true}).map((m,i) =>
        `<span class="move">${i%2==0?(Math.floor(i/2)+1)+'.':''}${m.san}</span>`).join('');
    }
    replaying = false;
    infoDiv.textContent = "Replay complete.";
  };

  helpBtn.onclick = async () => {
    helpInfo.textContent = "Thinking...";
    let move;
    if (difficultySel.value === 'hard') {
      move = await getBestMove(chess.fen(), chess.turn());
      helpInfo.textContent = `Best move (engine): ${move}`;
    } else {
      move = await getMostPopularMove(chess.fen());
      helpInfo.textContent = `Popular move: ${move}`;
    }
  };

  board = Chessboard('board', {
    draggable: true,
    position: 'start',
    onDrop: onDrop,
    onSnapEnd: onSnapEnd
  });

  updateUI();
</script>
</body>
</html>
